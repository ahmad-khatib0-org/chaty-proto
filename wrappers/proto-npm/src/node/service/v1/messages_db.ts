// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.0
//   protoc               unknown
// source: service/v1/messages_db.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { File } from "../../shared/v1/files.js";
import { StringArray } from "../../shared/v1/types.js";
import { Empty } from "../../shared/v1/wrappers.js";

export const protobufPackage = "service.v1";

/** Image positioning and size */
export enum ImageSize {
  /** LARGE - Show large preview at the bottom of the embed */
  LARGE = 0,
  /** PREVIEW - Show small preview to the side of the embed */
  PREVIEW = 1,
  UNRECOGNIZED = -1,
}

export function imageSizeFromJSON(object: any): ImageSize {
  switch (object) {
    case 0:
    case "LARGE":
      return ImageSize.LARGE;
    case 1:
    case "PREVIEW":
      return ImageSize.PREVIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImageSize.UNRECOGNIZED;
  }
}

export function imageSizeToJSON(object: ImageSize): string {
  switch (object) {
    case ImageSize.LARGE:
      return "LARGE";
    case ImageSize.PREVIEW:
      return "PREVIEW";
    case ImageSize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of remote Twitch content */
export enum TwitchType {
  TWITCH_CHANNEL = 0,
  TWITCH_VIDEO = 1,
  TWITCH_CLIP = 2,
  UNRECOGNIZED = -1,
}

export function twitchTypeFromJSON(object: any): TwitchType {
  switch (object) {
    case 0:
    case "TWITCH_CHANNEL":
      return TwitchType.TWITCH_CHANNEL;
    case 1:
    case "TWITCH_VIDEO":
      return TwitchType.TWITCH_VIDEO;
    case 2:
    case "TWITCH_CLIP":
      return TwitchType.TWITCH_CLIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TwitchType.UNRECOGNIZED;
  }
}

export function twitchTypeToJSON(object: TwitchType): string {
  switch (object) {
    case TwitchType.TWITCH_CHANNEL:
      return "TWITCH_CHANNEL";
    case TwitchType.TWITCH_VIDEO:
      return "TWITCH_VIDEO";
    case TwitchType.TWITCH_CLIP:
      return "TWITCH_CLIP";
    case TwitchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of remote Lightspeed.tv content */
export enum LightspeedType {
  LIGHTSPEED_CHANNEL = 0,
  UNRECOGNIZED = -1,
}

export function lightspeedTypeFromJSON(object: any): LightspeedType {
  switch (object) {
    case 0:
    case "LIGHTSPEED_CHANNEL":
      return LightspeedType.LIGHTSPEED_CHANNEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LightspeedType.UNRECOGNIZED;
  }
}

export function lightspeedTypeToJSON(object: LightspeedType): string {
  switch (object) {
    case LightspeedType.LIGHTSPEED_CHANNEL:
      return "LIGHTSPEED_CHANNEL";
    case LightspeedType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of remote Bandcamp content */
export enum BandcampType {
  BANDCAMP_ALBUM = 0,
  BANDCAMP_TRACK = 1,
  UNRECOGNIZED = -1,
}

export function bandcampTypeFromJSON(object: any): BandcampType {
  switch (object) {
    case 0:
    case "BANDCAMP_ALBUM":
      return BandcampType.BANDCAMP_ALBUM;
    case 1:
    case "BANDCAMP_TRACK":
      return BandcampType.BANDCAMP_TRACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BandcampType.UNRECOGNIZED;
  }
}

export function bandcampTypeToJSON(object: BandcampType): string {
  switch (object) {
    case BandcampType.BANDCAMP_ALBUM:
      return "BANDCAMP_ALBUM";
    case BandcampType.BANDCAMP_TRACK:
      return "BANDCAMP_TRACK";
    case BandcampType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ===========================================
 * MESSAGE WEBHOOK
 * ===========================================
 */
export interface MessageWebhook {
  /** The name of the webhook - 1 to 32 chars */
  name: string;
  /** The id of the avatar of the webhook, if it has one (optional) */
  avatar?: string | undefined;
}

/**
 * ===========================================
 * SYSTEM MESSAGE (oneof for enum variants)
 * ===========================================
 */
export interface MessageSystem {
  text?: MessageSystemText | undefined;
  userAdded?: MessageSystemUserAdded | undefined;
  userRemove?: MessageSystemUserRemove | undefined;
  userJoined?: MessageSystemUserJoined | undefined;
  userLeft?: MessageSystemUserLeft | undefined;
  userKicked?: MessageSystemUserKicked | undefined;
  userBanned?: MessageSystemUserBanned | undefined;
  channelRenamed?: MessageSystemChannelRenamed | undefined;
  channelDescriptionChanged?: MessageSystemChannelDescriptionChanged | undefined;
  channelIconChanged?: MessageSystemChannelIconChanged | undefined;
  channelOwnershipChanged?: MessageSystemChannelOwnershipChanged | undefined;
  messagePinned?: MessageSystemMessagePinned | undefined;
  messageUnpinned?: MessageSystemMessageUnpinned | undefined;
  callStarted?: MessageSystemCallStarted | undefined;
}

export interface MessageSystemText {
  content: string;
}

export interface MessageSystemUserAdded {
  id: string;
  by: string;
}

export interface MessageSystemUserRemove {
  id: string;
  by: string;
}

export interface MessageSystemUserJoined {
  id: string;
}

export interface MessageSystemUserLeft {
  id: string;
}

export interface MessageSystemUserKicked {
  id: string;
}

export interface MessageSystemUserBanned {
  id: string;
}

export interface MessageSystemChannelRenamed {
  name: string;
  by: string;
}

export interface MessageSystemChannelDescriptionChanged {
  by: string;
}

export interface MessageSystemChannelIconChanged {
  by: string;
}

export interface MessageSystemChannelOwnershipChanged {
  from: string;
  to: string;
}

export interface MessageSystemMessagePinned {
  id: string;
  by: string;
}

export interface MessageSystemMessageUnpinned {
  id: string;
  by: string;
}

export interface MessageSystemCallStarted {
  by: string;
  finishedAt: string;
}

/** Image */
export interface EmbedImage {
  /** URL to the original image */
  url: string;
  /** Width of the image */
  width: number;
  /** Height of the image */
  height: number;
  /** Positioning and size */
  size: ImageSize;
}

/** Video */
export interface EmbedVideo {
  /** URL to the original video */
  url: string;
  /** Width of the video */
  width: number;
  /** Height of the video */
  height: number;
}

/** Information about special remote content */
export interface EmbedWebsiteMetadataSpecial {
  /** No remote content */
  none?:
    | Empty
    | undefined;
  /** Content hint that this contains a GIF (use metadata to find video or image to play) */
  gif?:
    | Empty
    | undefined;
  /** YouTube video */
  youtube?:
    | EmbedYouTube
    | undefined;
  /** Lightspeed.tv stream */
  lightspeed?:
    | EmbedLightspeed
    | undefined;
  /** Twitch stream or clip */
  twitch?:
    | EmbedTwitch
    | undefined;
  /** Spotify track */
  spotify?:
    | EmbedSpotify
    | undefined;
  /** Soundcloud track */
  soundcloud?:
    | Empty
    | undefined;
  /** Bandcamp track */
  bandcamp?:
    | EmbedBandcamp
    | undefined;
  /** Apple Music */
  appleMusic?:
    | EmbedAppleMusic
    | undefined;
  /** Streamable Video */
  streamable?: EmbedStreamable | undefined;
}

/** YouTube video */
export interface EmbedYouTube {
  id: string;
  timestamp?: string | undefined;
}

/** Lightspeed.tv stream */
export interface EmbedLightspeed {
  contentType: LightspeedType;
  id: string;
}

/** Twitch stream or clip */
export interface EmbedTwitch {
  contentType: TwitchType;
  id: string;
}

/** Spotify track */
export interface EmbedSpotify {
  /** Free-form string */
  contentType: string;
  id: string;
}

/** Bandcamp track */
export interface EmbedBandcamp {
  contentType: BandcampType;
  id: string;
}

/** Apple Music */
export interface EmbedAppleMusic {
  albumId: string;
  /** optional */
  trackId: string;
}

/** Streamable Video */
export interface EmbedStreamable {
  id: string;
}

/** Website metadata */
export interface EmbedWebsiteMetadata {
  /** Direct URL to web page (optional) */
  url?:
    | string
    | undefined;
  /** Original direct URL (optional) */
  originalUrl?:
    | string
    | undefined;
  /** Remote content (optional) */
  special?:
    | EmbedWebsiteMetadataSpecial
    | undefined;
  /** Title of website (optional) */
  title?:
    | string
    | undefined;
  /** Description of website (optional) */
  description?:
    | string
    | undefined;
  /** Embedded image (optional) */
  image?:
    | EmbedImage
    | undefined;
  /** Embedded video (optional) */
  video?:
    | EmbedVideo
    | undefined;
  /** Site name (optional) */
  siteName?:
    | string
    | undefined;
  /** URL to site icon (optional) */
  iconUrl?:
    | string
    | undefined;
  /** CSS Colour (optional) */
  colour?: string | undefined;
}

/** Text Embed */
export interface EmbedText {
  /** URL to icon (optional) */
  iconUrl?:
    | string
    | undefined;
  /** URL for title (optional) */
  url?:
    | string
    | undefined;
  /** Title of text embed (optional) */
  title?:
    | string
    | undefined;
  /** Description of text embed (optional) */
  description?:
    | string
    | undefined;
  /** ID of uploaded autumn file (optional) */
  media?:
    | File
    | undefined;
  /** CSS Colour (optional) */
  colour?: string | undefined;
}

/** Embed (oneof for different embed types) */
export interface Embed {
  website?: EmbedWebsiteMetadata | undefined;
  image?: EmbedImage | undefined;
  video?: EmbedVideo | undefined;
  text?: EmbedText | undefined;
  none?: Empty | undefined;
}

/**
 * ===========================================
 * INTERACTIONS
 * ===========================================
 */
export interface Interactions {
  /** Reactions which should always appear and be distinct (optional) */
  reactions: string[];
  /** Whether reactions should be restricted to the given list */
  restrictReactions: boolean;
}

/**
 * ===========================================
 * MASQUERADE
 * ===========================================
 */
export interface Masquerade {
  /** Replace the display name shown on this message (optional) */
  name?:
    | string
    | undefined;
  /** Replace the avatar shown on this message (URL to image file) (optional) */
  avatar?:
    | string
    | undefined;
  /** Replace the display role colour shown on this message (optional) */
  colour?: string | undefined;
}

/**
 * ===========================================
 * MAIN MESSAGE
 * ===========================================
 */
export interface Message {
  /** Unique Id */
  id: string;
  /** Unique value generated by client sending this message (optional) */
  nonce?:
    | string
    | undefined;
  /** Id of the channel this message was sent in */
  channelId: string;
  /** Id of the user or webhook that sent this message */
  authorId: string;
  /** The webhook that sent this message (optional) */
  webhook?:
    | MessageWebhook
    | undefined;
  /** Message content (optional) */
  content?:
    | string
    | undefined;
  /** System message (optional) */
  system?:
    | MessageSystem
    | undefined;
  /** Array of attachments (optional) */
  attachments: File[];
  /** Time at which this message was last edited (optional) */
  edited?:
    | string
    | undefined;
  /** Attached embeds to this message (optional) */
  embeds: Embed[];
  /** Array of user ids mentioned in this message (optional) */
  mentions: string[];
  /** Array of role ids mentioned in this message (optional) */
  roleMentions: string[];
  /** Array of message ids this message is replying to (optional) */
  replies: string[];
  /** Hashmap of emoji IDs to array of user IDs */
  reactions: { [key: string]: StringArray };
  /** Information about how this message should be interacted with */
  interactions?:
    | Interactions
    | undefined;
  /** Name and / or avatar overrides for this message (optional) */
  masquerade?:
    | Masquerade
    | undefined;
  /** Whether or not the message is pinned (optional) */
  pinned?:
    | boolean
    | undefined;
  /** Bitfield of message flags (optional) */
  flags?: number | undefined;
}

export interface Message_ReactionsEntry {
  key: string;
  value?: StringArray | undefined;
}

function createBaseMessageWebhook(): MessageWebhook {
  return { name: "", avatar: undefined };
}

export const MessageWebhook: MessageFns<MessageWebhook> = {
  encode(message: MessageWebhook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.avatar !== undefined) {
      writer.uint32(18).string(message.avatar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageWebhook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageWebhook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageWebhook {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : undefined,
    };
  },

  toJSON(message: MessageWebhook): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.avatar !== undefined) {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageWebhook>, I>>(base?: I): MessageWebhook {
    return MessageWebhook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageWebhook>, I>>(object: I): MessageWebhook {
    const message = createBaseMessageWebhook();
    message.name = object.name ?? "";
    message.avatar = object.avatar ?? undefined;
    return message;
  },
};

function createBaseMessageSystem(): MessageSystem {
  return {
    text: undefined,
    userAdded: undefined,
    userRemove: undefined,
    userJoined: undefined,
    userLeft: undefined,
    userKicked: undefined,
    userBanned: undefined,
    channelRenamed: undefined,
    channelDescriptionChanged: undefined,
    channelIconChanged: undefined,
    channelOwnershipChanged: undefined,
    messagePinned: undefined,
    messageUnpinned: undefined,
    callStarted: undefined,
  };
}

export const MessageSystem: MessageFns<MessageSystem> = {
  encode(message: MessageSystem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      MessageSystemText.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.userAdded !== undefined) {
      MessageSystemUserAdded.encode(message.userAdded, writer.uint32(18).fork()).join();
    }
    if (message.userRemove !== undefined) {
      MessageSystemUserRemove.encode(message.userRemove, writer.uint32(26).fork()).join();
    }
    if (message.userJoined !== undefined) {
      MessageSystemUserJoined.encode(message.userJoined, writer.uint32(34).fork()).join();
    }
    if (message.userLeft !== undefined) {
      MessageSystemUserLeft.encode(message.userLeft, writer.uint32(42).fork()).join();
    }
    if (message.userKicked !== undefined) {
      MessageSystemUserKicked.encode(message.userKicked, writer.uint32(50).fork()).join();
    }
    if (message.userBanned !== undefined) {
      MessageSystemUserBanned.encode(message.userBanned, writer.uint32(58).fork()).join();
    }
    if (message.channelRenamed !== undefined) {
      MessageSystemChannelRenamed.encode(message.channelRenamed, writer.uint32(66).fork()).join();
    }
    if (message.channelDescriptionChanged !== undefined) {
      MessageSystemChannelDescriptionChanged.encode(message.channelDescriptionChanged, writer.uint32(74).fork()).join();
    }
    if (message.channelIconChanged !== undefined) {
      MessageSystemChannelIconChanged.encode(message.channelIconChanged, writer.uint32(82).fork()).join();
    }
    if (message.channelOwnershipChanged !== undefined) {
      MessageSystemChannelOwnershipChanged.encode(message.channelOwnershipChanged, writer.uint32(90).fork()).join();
    }
    if (message.messagePinned !== undefined) {
      MessageSystemMessagePinned.encode(message.messagePinned, writer.uint32(98).fork()).join();
    }
    if (message.messageUnpinned !== undefined) {
      MessageSystemMessageUnpinned.encode(message.messageUnpinned, writer.uint32(106).fork()).join();
    }
    if (message.callStarted !== undefined) {
      MessageSystemCallStarted.encode(message.callStarted, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = MessageSystemText.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userAdded = MessageSystemUserAdded.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userRemove = MessageSystemUserRemove.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userJoined = MessageSystemUserJoined.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userLeft = MessageSystemUserLeft.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userKicked = MessageSystemUserKicked.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userBanned = MessageSystemUserBanned.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.channelRenamed = MessageSystemChannelRenamed.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.channelDescriptionChanged = MessageSystemChannelDescriptionChanged.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.channelIconChanged = MessageSystemChannelIconChanged.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.channelOwnershipChanged = MessageSystemChannelOwnershipChanged.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.messagePinned = MessageSystemMessagePinned.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.messageUnpinned = MessageSystemMessageUnpinned.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.callStarted = MessageSystemCallStarted.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystem {
    return {
      text: isSet(object.text) ? MessageSystemText.fromJSON(object.text) : undefined,
      userAdded: isSet(object.userAdded) ? MessageSystemUserAdded.fromJSON(object.userAdded) : undefined,
      userRemove: isSet(object.userRemove) ? MessageSystemUserRemove.fromJSON(object.userRemove) : undefined,
      userJoined: isSet(object.userJoined) ? MessageSystemUserJoined.fromJSON(object.userJoined) : undefined,
      userLeft: isSet(object.userLeft) ? MessageSystemUserLeft.fromJSON(object.userLeft) : undefined,
      userKicked: isSet(object.userKicked) ? MessageSystemUserKicked.fromJSON(object.userKicked) : undefined,
      userBanned: isSet(object.userBanned) ? MessageSystemUserBanned.fromJSON(object.userBanned) : undefined,
      channelRenamed: isSet(object.channelRenamed)
        ? MessageSystemChannelRenamed.fromJSON(object.channelRenamed)
        : undefined,
      channelDescriptionChanged: isSet(object.channelDescriptionChanged)
        ? MessageSystemChannelDescriptionChanged.fromJSON(object.channelDescriptionChanged)
        : undefined,
      channelIconChanged: isSet(object.channelIconChanged)
        ? MessageSystemChannelIconChanged.fromJSON(object.channelIconChanged)
        : undefined,
      channelOwnershipChanged: isSet(object.channelOwnershipChanged)
        ? MessageSystemChannelOwnershipChanged.fromJSON(object.channelOwnershipChanged)
        : undefined,
      messagePinned: isSet(object.messagePinned)
        ? MessageSystemMessagePinned.fromJSON(object.messagePinned)
        : undefined,
      messageUnpinned: isSet(object.messageUnpinned)
        ? MessageSystemMessageUnpinned.fromJSON(object.messageUnpinned)
        : undefined,
      callStarted: isSet(object.callStarted) ? MessageSystemCallStarted.fromJSON(object.callStarted) : undefined,
    };
  },

  toJSON(message: MessageSystem): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = MessageSystemText.toJSON(message.text);
    }
    if (message.userAdded !== undefined) {
      obj.userAdded = MessageSystemUserAdded.toJSON(message.userAdded);
    }
    if (message.userRemove !== undefined) {
      obj.userRemove = MessageSystemUserRemove.toJSON(message.userRemove);
    }
    if (message.userJoined !== undefined) {
      obj.userJoined = MessageSystemUserJoined.toJSON(message.userJoined);
    }
    if (message.userLeft !== undefined) {
      obj.userLeft = MessageSystemUserLeft.toJSON(message.userLeft);
    }
    if (message.userKicked !== undefined) {
      obj.userKicked = MessageSystemUserKicked.toJSON(message.userKicked);
    }
    if (message.userBanned !== undefined) {
      obj.userBanned = MessageSystemUserBanned.toJSON(message.userBanned);
    }
    if (message.channelRenamed !== undefined) {
      obj.channelRenamed = MessageSystemChannelRenamed.toJSON(message.channelRenamed);
    }
    if (message.channelDescriptionChanged !== undefined) {
      obj.channelDescriptionChanged = MessageSystemChannelDescriptionChanged.toJSON(message.channelDescriptionChanged);
    }
    if (message.channelIconChanged !== undefined) {
      obj.channelIconChanged = MessageSystemChannelIconChanged.toJSON(message.channelIconChanged);
    }
    if (message.channelOwnershipChanged !== undefined) {
      obj.channelOwnershipChanged = MessageSystemChannelOwnershipChanged.toJSON(message.channelOwnershipChanged);
    }
    if (message.messagePinned !== undefined) {
      obj.messagePinned = MessageSystemMessagePinned.toJSON(message.messagePinned);
    }
    if (message.messageUnpinned !== undefined) {
      obj.messageUnpinned = MessageSystemMessageUnpinned.toJSON(message.messageUnpinned);
    }
    if (message.callStarted !== undefined) {
      obj.callStarted = MessageSystemCallStarted.toJSON(message.callStarted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystem>, I>>(base?: I): MessageSystem {
    return MessageSystem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystem>, I>>(object: I): MessageSystem {
    const message = createBaseMessageSystem();
    message.text = (object.text !== undefined && object.text !== null)
      ? MessageSystemText.fromPartial(object.text)
      : undefined;
    message.userAdded = (object.userAdded !== undefined && object.userAdded !== null)
      ? MessageSystemUserAdded.fromPartial(object.userAdded)
      : undefined;
    message.userRemove = (object.userRemove !== undefined && object.userRemove !== null)
      ? MessageSystemUserRemove.fromPartial(object.userRemove)
      : undefined;
    message.userJoined = (object.userJoined !== undefined && object.userJoined !== null)
      ? MessageSystemUserJoined.fromPartial(object.userJoined)
      : undefined;
    message.userLeft = (object.userLeft !== undefined && object.userLeft !== null)
      ? MessageSystemUserLeft.fromPartial(object.userLeft)
      : undefined;
    message.userKicked = (object.userKicked !== undefined && object.userKicked !== null)
      ? MessageSystemUserKicked.fromPartial(object.userKicked)
      : undefined;
    message.userBanned = (object.userBanned !== undefined && object.userBanned !== null)
      ? MessageSystemUserBanned.fromPartial(object.userBanned)
      : undefined;
    message.channelRenamed = (object.channelRenamed !== undefined && object.channelRenamed !== null)
      ? MessageSystemChannelRenamed.fromPartial(object.channelRenamed)
      : undefined;
    message.channelDescriptionChanged =
      (object.channelDescriptionChanged !== undefined && object.channelDescriptionChanged !== null)
        ? MessageSystemChannelDescriptionChanged.fromPartial(object.channelDescriptionChanged)
        : undefined;
    message.channelIconChanged = (object.channelIconChanged !== undefined && object.channelIconChanged !== null)
      ? MessageSystemChannelIconChanged.fromPartial(object.channelIconChanged)
      : undefined;
    message.channelOwnershipChanged =
      (object.channelOwnershipChanged !== undefined && object.channelOwnershipChanged !== null)
        ? MessageSystemChannelOwnershipChanged.fromPartial(object.channelOwnershipChanged)
        : undefined;
    message.messagePinned = (object.messagePinned !== undefined && object.messagePinned !== null)
      ? MessageSystemMessagePinned.fromPartial(object.messagePinned)
      : undefined;
    message.messageUnpinned = (object.messageUnpinned !== undefined && object.messageUnpinned !== null)
      ? MessageSystemMessageUnpinned.fromPartial(object.messageUnpinned)
      : undefined;
    message.callStarted = (object.callStarted !== undefined && object.callStarted !== null)
      ? MessageSystemCallStarted.fromPartial(object.callStarted)
      : undefined;
    return message;
  },
};

function createBaseMessageSystemText(): MessageSystemText {
  return { content: "" };
}

export const MessageSystemText: MessageFns<MessageSystemText> = {
  encode(message: MessageSystemText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemText {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: MessageSystemText): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemText>, I>>(base?: I): MessageSystemText {
    return MessageSystemText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemText>, I>>(object: I): MessageSystemText {
    const message = createBaseMessageSystemText();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseMessageSystemUserAdded(): MessageSystemUserAdded {
  return { id: "", by: "" };
}

export const MessageSystemUserAdded: MessageFns<MessageSystemUserAdded> = {
  encode(message: MessageSystemUserAdded, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.by !== "") {
      writer.uint32(18).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemUserAdded {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemUserAdded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemUserAdded {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      by: isSet(object.by) ? globalThis.String(object.by) : "",
    };
  },

  toJSON(message: MessageSystemUserAdded): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemUserAdded>, I>>(base?: I): MessageSystemUserAdded {
    return MessageSystemUserAdded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemUserAdded>, I>>(object: I): MessageSystemUserAdded {
    const message = createBaseMessageSystemUserAdded();
    message.id = object.id ?? "";
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseMessageSystemUserRemove(): MessageSystemUserRemove {
  return { id: "", by: "" };
}

export const MessageSystemUserRemove: MessageFns<MessageSystemUserRemove> = {
  encode(message: MessageSystemUserRemove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.by !== "") {
      writer.uint32(18).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemUserRemove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemUserRemove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemUserRemove {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      by: isSet(object.by) ? globalThis.String(object.by) : "",
    };
  },

  toJSON(message: MessageSystemUserRemove): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemUserRemove>, I>>(base?: I): MessageSystemUserRemove {
    return MessageSystemUserRemove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemUserRemove>, I>>(object: I): MessageSystemUserRemove {
    const message = createBaseMessageSystemUserRemove();
    message.id = object.id ?? "";
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseMessageSystemUserJoined(): MessageSystemUserJoined {
  return { id: "" };
}

export const MessageSystemUserJoined: MessageFns<MessageSystemUserJoined> = {
  encode(message: MessageSystemUserJoined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemUserJoined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemUserJoined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemUserJoined {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: MessageSystemUserJoined): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemUserJoined>, I>>(base?: I): MessageSystemUserJoined {
    return MessageSystemUserJoined.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemUserJoined>, I>>(object: I): MessageSystemUserJoined {
    const message = createBaseMessageSystemUserJoined();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseMessageSystemUserLeft(): MessageSystemUserLeft {
  return { id: "" };
}

export const MessageSystemUserLeft: MessageFns<MessageSystemUserLeft> = {
  encode(message: MessageSystemUserLeft, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemUserLeft {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemUserLeft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemUserLeft {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: MessageSystemUserLeft): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemUserLeft>, I>>(base?: I): MessageSystemUserLeft {
    return MessageSystemUserLeft.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemUserLeft>, I>>(object: I): MessageSystemUserLeft {
    const message = createBaseMessageSystemUserLeft();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseMessageSystemUserKicked(): MessageSystemUserKicked {
  return { id: "" };
}

export const MessageSystemUserKicked: MessageFns<MessageSystemUserKicked> = {
  encode(message: MessageSystemUserKicked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemUserKicked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemUserKicked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemUserKicked {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: MessageSystemUserKicked): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemUserKicked>, I>>(base?: I): MessageSystemUserKicked {
    return MessageSystemUserKicked.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemUserKicked>, I>>(object: I): MessageSystemUserKicked {
    const message = createBaseMessageSystemUserKicked();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseMessageSystemUserBanned(): MessageSystemUserBanned {
  return { id: "" };
}

export const MessageSystemUserBanned: MessageFns<MessageSystemUserBanned> = {
  encode(message: MessageSystemUserBanned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemUserBanned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemUserBanned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemUserBanned {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: MessageSystemUserBanned): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemUserBanned>, I>>(base?: I): MessageSystemUserBanned {
    return MessageSystemUserBanned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemUserBanned>, I>>(object: I): MessageSystemUserBanned {
    const message = createBaseMessageSystemUserBanned();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseMessageSystemChannelRenamed(): MessageSystemChannelRenamed {
  return { name: "", by: "" };
}

export const MessageSystemChannelRenamed: MessageFns<MessageSystemChannelRenamed> = {
  encode(message: MessageSystemChannelRenamed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.by !== "") {
      writer.uint32(18).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemChannelRenamed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemChannelRenamed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemChannelRenamed {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      by: isSet(object.by) ? globalThis.String(object.by) : "",
    };
  },

  toJSON(message: MessageSystemChannelRenamed): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemChannelRenamed>, I>>(base?: I): MessageSystemChannelRenamed {
    return MessageSystemChannelRenamed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemChannelRenamed>, I>>(object: I): MessageSystemChannelRenamed {
    const message = createBaseMessageSystemChannelRenamed();
    message.name = object.name ?? "";
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseMessageSystemChannelDescriptionChanged(): MessageSystemChannelDescriptionChanged {
  return { by: "" };
}

export const MessageSystemChannelDescriptionChanged: MessageFns<MessageSystemChannelDescriptionChanged> = {
  encode(message: MessageSystemChannelDescriptionChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.by !== "") {
      writer.uint32(10).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemChannelDescriptionChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemChannelDescriptionChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemChannelDescriptionChanged {
    return { by: isSet(object.by) ? globalThis.String(object.by) : "" };
  },

  toJSON(message: MessageSystemChannelDescriptionChanged): unknown {
    const obj: any = {};
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemChannelDescriptionChanged>, I>>(
    base?: I,
  ): MessageSystemChannelDescriptionChanged {
    return MessageSystemChannelDescriptionChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemChannelDescriptionChanged>, I>>(
    object: I,
  ): MessageSystemChannelDescriptionChanged {
    const message = createBaseMessageSystemChannelDescriptionChanged();
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseMessageSystemChannelIconChanged(): MessageSystemChannelIconChanged {
  return { by: "" };
}

export const MessageSystemChannelIconChanged: MessageFns<MessageSystemChannelIconChanged> = {
  encode(message: MessageSystemChannelIconChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.by !== "") {
      writer.uint32(10).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemChannelIconChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemChannelIconChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemChannelIconChanged {
    return { by: isSet(object.by) ? globalThis.String(object.by) : "" };
  },

  toJSON(message: MessageSystemChannelIconChanged): unknown {
    const obj: any = {};
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemChannelIconChanged>, I>>(base?: I): MessageSystemChannelIconChanged {
    return MessageSystemChannelIconChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemChannelIconChanged>, I>>(
    object: I,
  ): MessageSystemChannelIconChanged {
    const message = createBaseMessageSystemChannelIconChanged();
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseMessageSystemChannelOwnershipChanged(): MessageSystemChannelOwnershipChanged {
  return { from: "", to: "" };
}

export const MessageSystemChannelOwnershipChanged: MessageFns<MessageSystemChannelOwnershipChanged> = {
  encode(message: MessageSystemChannelOwnershipChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemChannelOwnershipChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemChannelOwnershipChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemChannelOwnershipChanged {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
    };
  },

  toJSON(message: MessageSystemChannelOwnershipChanged): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemChannelOwnershipChanged>, I>>(
    base?: I,
  ): MessageSystemChannelOwnershipChanged {
    return MessageSystemChannelOwnershipChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemChannelOwnershipChanged>, I>>(
    object: I,
  ): MessageSystemChannelOwnershipChanged {
    const message = createBaseMessageSystemChannelOwnershipChanged();
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    return message;
  },
};

function createBaseMessageSystemMessagePinned(): MessageSystemMessagePinned {
  return { id: "", by: "" };
}

export const MessageSystemMessagePinned: MessageFns<MessageSystemMessagePinned> = {
  encode(message: MessageSystemMessagePinned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.by !== "") {
      writer.uint32(18).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemMessagePinned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemMessagePinned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemMessagePinned {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      by: isSet(object.by) ? globalThis.String(object.by) : "",
    };
  },

  toJSON(message: MessageSystemMessagePinned): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemMessagePinned>, I>>(base?: I): MessageSystemMessagePinned {
    return MessageSystemMessagePinned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemMessagePinned>, I>>(object: I): MessageSystemMessagePinned {
    const message = createBaseMessageSystemMessagePinned();
    message.id = object.id ?? "";
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseMessageSystemMessageUnpinned(): MessageSystemMessageUnpinned {
  return { id: "", by: "" };
}

export const MessageSystemMessageUnpinned: MessageFns<MessageSystemMessageUnpinned> = {
  encode(message: MessageSystemMessageUnpinned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.by !== "") {
      writer.uint32(18).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemMessageUnpinned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemMessageUnpinned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemMessageUnpinned {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      by: isSet(object.by) ? globalThis.String(object.by) : "",
    };
  },

  toJSON(message: MessageSystemMessageUnpinned): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemMessageUnpinned>, I>>(base?: I): MessageSystemMessageUnpinned {
    return MessageSystemMessageUnpinned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemMessageUnpinned>, I>>(object: I): MessageSystemMessageUnpinned {
    const message = createBaseMessageSystemMessageUnpinned();
    message.id = object.id ?? "";
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseMessageSystemCallStarted(): MessageSystemCallStarted {
  return { by: "", finishedAt: "0" };
}

export const MessageSystemCallStarted: MessageFns<MessageSystemCallStarted> = {
  encode(message: MessageSystemCallStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.by !== "") {
      writer.uint32(10).string(message.by);
    }
    if (message.finishedAt !== "0") {
      writer.uint32(16).int64(message.finishedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageSystemCallStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSystemCallStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.by = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finishedAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSystemCallStarted {
    return {
      by: isSet(object.by) ? globalThis.String(object.by) : "",
      finishedAt: isSet(object.finishedAt) ? globalThis.String(object.finishedAt) : "0",
    };
  },

  toJSON(message: MessageSystemCallStarted): unknown {
    const obj: any = {};
    if (message.by !== "") {
      obj.by = message.by;
    }
    if (message.finishedAt !== "0") {
      obj.finishedAt = message.finishedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSystemCallStarted>, I>>(base?: I): MessageSystemCallStarted {
    return MessageSystemCallStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSystemCallStarted>, I>>(object: I): MessageSystemCallStarted {
    const message = createBaseMessageSystemCallStarted();
    message.by = object.by ?? "";
    message.finishedAt = object.finishedAt ?? "0";
    return message;
  },
};

function createBaseEmbedImage(): EmbedImage {
  return { url: "", width: 0, height: 0, size: 0 };
}

export const EmbedImage: MessageFns<EmbedImage> = {
  encode(message: EmbedImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.size !== 0) {
      writer.uint32(32).int32(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedImage {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      size: isSet(object.size) ? imageSizeFromJSON(object.size) : 0,
    };
  },

  toJSON(message: EmbedImage): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.size !== 0) {
      obj.size = imageSizeToJSON(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedImage>, I>>(base?: I): EmbedImage {
    return EmbedImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedImage>, I>>(object: I): EmbedImage {
    const message = createBaseEmbedImage();
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseEmbedVideo(): EmbedVideo {
  return { url: "", width: 0, height: 0 };
}

export const EmbedVideo: MessageFns<EmbedVideo> = {
  encode(message: EmbedVideo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedVideo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedVideo {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: EmbedVideo): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedVideo>, I>>(base?: I): EmbedVideo {
    return EmbedVideo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedVideo>, I>>(object: I): EmbedVideo {
    const message = createBaseEmbedVideo();
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseEmbedWebsiteMetadataSpecial(): EmbedWebsiteMetadataSpecial {
  return {
    none: undefined,
    gif: undefined,
    youtube: undefined,
    lightspeed: undefined,
    twitch: undefined,
    spotify: undefined,
    soundcloud: undefined,
    bandcamp: undefined,
    appleMusic: undefined,
    streamable: undefined,
  };
}

export const EmbedWebsiteMetadataSpecial: MessageFns<EmbedWebsiteMetadataSpecial> = {
  encode(message: EmbedWebsiteMetadataSpecial, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.none !== undefined) {
      Empty.encode(message.none, writer.uint32(10).fork()).join();
    }
    if (message.gif !== undefined) {
      Empty.encode(message.gif, writer.uint32(18).fork()).join();
    }
    if (message.youtube !== undefined) {
      EmbedYouTube.encode(message.youtube, writer.uint32(26).fork()).join();
    }
    if (message.lightspeed !== undefined) {
      EmbedLightspeed.encode(message.lightspeed, writer.uint32(34).fork()).join();
    }
    if (message.twitch !== undefined) {
      EmbedTwitch.encode(message.twitch, writer.uint32(42).fork()).join();
    }
    if (message.spotify !== undefined) {
      EmbedSpotify.encode(message.spotify, writer.uint32(50).fork()).join();
    }
    if (message.soundcloud !== undefined) {
      Empty.encode(message.soundcloud, writer.uint32(58).fork()).join();
    }
    if (message.bandcamp !== undefined) {
      EmbedBandcamp.encode(message.bandcamp, writer.uint32(66).fork()).join();
    }
    if (message.appleMusic !== undefined) {
      EmbedAppleMusic.encode(message.appleMusic, writer.uint32(74).fork()).join();
    }
    if (message.streamable !== undefined) {
      EmbedStreamable.encode(message.streamable, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedWebsiteMetadataSpecial {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedWebsiteMetadataSpecial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.none = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gif = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.youtube = EmbedYouTube.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lightspeed = EmbedLightspeed.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.twitch = EmbedTwitch.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.spotify = EmbedSpotify.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.soundcloud = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bandcamp = EmbedBandcamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.appleMusic = EmbedAppleMusic.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.streamable = EmbedStreamable.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedWebsiteMetadataSpecial {
    return {
      none: isSet(object.none) ? Empty.fromJSON(object.none) : undefined,
      gif: isSet(object.gif) ? Empty.fromJSON(object.gif) : undefined,
      youtube: isSet(object.youtube) ? EmbedYouTube.fromJSON(object.youtube) : undefined,
      lightspeed: isSet(object.lightspeed) ? EmbedLightspeed.fromJSON(object.lightspeed) : undefined,
      twitch: isSet(object.twitch) ? EmbedTwitch.fromJSON(object.twitch) : undefined,
      spotify: isSet(object.spotify) ? EmbedSpotify.fromJSON(object.spotify) : undefined,
      soundcloud: isSet(object.soundcloud) ? Empty.fromJSON(object.soundcloud) : undefined,
      bandcamp: isSet(object.bandcamp) ? EmbedBandcamp.fromJSON(object.bandcamp) : undefined,
      appleMusic: isSet(object.appleMusic) ? EmbedAppleMusic.fromJSON(object.appleMusic) : undefined,
      streamable: isSet(object.streamable) ? EmbedStreamable.fromJSON(object.streamable) : undefined,
    };
  },

  toJSON(message: EmbedWebsiteMetadataSpecial): unknown {
    const obj: any = {};
    if (message.none !== undefined) {
      obj.none = Empty.toJSON(message.none);
    }
    if (message.gif !== undefined) {
      obj.gif = Empty.toJSON(message.gif);
    }
    if (message.youtube !== undefined) {
      obj.youtube = EmbedYouTube.toJSON(message.youtube);
    }
    if (message.lightspeed !== undefined) {
      obj.lightspeed = EmbedLightspeed.toJSON(message.lightspeed);
    }
    if (message.twitch !== undefined) {
      obj.twitch = EmbedTwitch.toJSON(message.twitch);
    }
    if (message.spotify !== undefined) {
      obj.spotify = EmbedSpotify.toJSON(message.spotify);
    }
    if (message.soundcloud !== undefined) {
      obj.soundcloud = Empty.toJSON(message.soundcloud);
    }
    if (message.bandcamp !== undefined) {
      obj.bandcamp = EmbedBandcamp.toJSON(message.bandcamp);
    }
    if (message.appleMusic !== undefined) {
      obj.appleMusic = EmbedAppleMusic.toJSON(message.appleMusic);
    }
    if (message.streamable !== undefined) {
      obj.streamable = EmbedStreamable.toJSON(message.streamable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedWebsiteMetadataSpecial>, I>>(base?: I): EmbedWebsiteMetadataSpecial {
    return EmbedWebsiteMetadataSpecial.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedWebsiteMetadataSpecial>, I>>(object: I): EmbedWebsiteMetadataSpecial {
    const message = createBaseEmbedWebsiteMetadataSpecial();
    message.none = (object.none !== undefined && object.none !== null) ? Empty.fromPartial(object.none) : undefined;
    message.gif = (object.gif !== undefined && object.gif !== null) ? Empty.fromPartial(object.gif) : undefined;
    message.youtube = (object.youtube !== undefined && object.youtube !== null)
      ? EmbedYouTube.fromPartial(object.youtube)
      : undefined;
    message.lightspeed = (object.lightspeed !== undefined && object.lightspeed !== null)
      ? EmbedLightspeed.fromPartial(object.lightspeed)
      : undefined;
    message.twitch = (object.twitch !== undefined && object.twitch !== null)
      ? EmbedTwitch.fromPartial(object.twitch)
      : undefined;
    message.spotify = (object.spotify !== undefined && object.spotify !== null)
      ? EmbedSpotify.fromPartial(object.spotify)
      : undefined;
    message.soundcloud = (object.soundcloud !== undefined && object.soundcloud !== null)
      ? Empty.fromPartial(object.soundcloud)
      : undefined;
    message.bandcamp = (object.bandcamp !== undefined && object.bandcamp !== null)
      ? EmbedBandcamp.fromPartial(object.bandcamp)
      : undefined;
    message.appleMusic = (object.appleMusic !== undefined && object.appleMusic !== null)
      ? EmbedAppleMusic.fromPartial(object.appleMusic)
      : undefined;
    message.streamable = (object.streamable !== undefined && object.streamable !== null)
      ? EmbedStreamable.fromPartial(object.streamable)
      : undefined;
    return message;
  },
};

function createBaseEmbedYouTube(): EmbedYouTube {
  return { id: "", timestamp: undefined };
}

export const EmbedYouTube: MessageFns<EmbedYouTube> = {
  encode(message: EmbedYouTube, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== undefined) {
      writer.uint32(18).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedYouTube {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedYouTube();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedYouTube {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : undefined,
    };
  },

  toJSON(message: EmbedYouTube): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedYouTube>, I>>(base?: I): EmbedYouTube {
    return EmbedYouTube.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedYouTube>, I>>(object: I): EmbedYouTube {
    const message = createBaseEmbedYouTube();
    message.id = object.id ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseEmbedLightspeed(): EmbedLightspeed {
  return { contentType: 0, id: "" };
}

export const EmbedLightspeed: MessageFns<EmbedLightspeed> = {
  encode(message: EmbedLightspeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentType !== 0) {
      writer.uint32(8).int32(message.contentType);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedLightspeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedLightspeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedLightspeed {
    return {
      contentType: isSet(object.contentType) ? lightspeedTypeFromJSON(object.contentType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: EmbedLightspeed): unknown {
    const obj: any = {};
    if (message.contentType !== 0) {
      obj.contentType = lightspeedTypeToJSON(message.contentType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedLightspeed>, I>>(base?: I): EmbedLightspeed {
    return EmbedLightspeed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedLightspeed>, I>>(object: I): EmbedLightspeed {
    const message = createBaseEmbedLightspeed();
    message.contentType = object.contentType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseEmbedTwitch(): EmbedTwitch {
  return { contentType: 0, id: "" };
}

export const EmbedTwitch: MessageFns<EmbedTwitch> = {
  encode(message: EmbedTwitch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentType !== 0) {
      writer.uint32(8).int32(message.contentType);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedTwitch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedTwitch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedTwitch {
    return {
      contentType: isSet(object.contentType) ? twitchTypeFromJSON(object.contentType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: EmbedTwitch): unknown {
    const obj: any = {};
    if (message.contentType !== 0) {
      obj.contentType = twitchTypeToJSON(message.contentType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedTwitch>, I>>(base?: I): EmbedTwitch {
    return EmbedTwitch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedTwitch>, I>>(object: I): EmbedTwitch {
    const message = createBaseEmbedTwitch();
    message.contentType = object.contentType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseEmbedSpotify(): EmbedSpotify {
  return { contentType: "", id: "" };
}

export const EmbedSpotify: MessageFns<EmbedSpotify> = {
  encode(message: EmbedSpotify, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentType !== "") {
      writer.uint32(10).string(message.contentType);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedSpotify {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedSpotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedSpotify {
    return {
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: EmbedSpotify): unknown {
    const obj: any = {};
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedSpotify>, I>>(base?: I): EmbedSpotify {
    return EmbedSpotify.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedSpotify>, I>>(object: I): EmbedSpotify {
    const message = createBaseEmbedSpotify();
    message.contentType = object.contentType ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseEmbedBandcamp(): EmbedBandcamp {
  return { contentType: 0, id: "" };
}

export const EmbedBandcamp: MessageFns<EmbedBandcamp> = {
  encode(message: EmbedBandcamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentType !== 0) {
      writer.uint32(8).int32(message.contentType);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedBandcamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedBandcamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedBandcamp {
    return {
      contentType: isSet(object.contentType) ? bandcampTypeFromJSON(object.contentType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: EmbedBandcamp): unknown {
    const obj: any = {};
    if (message.contentType !== 0) {
      obj.contentType = bandcampTypeToJSON(message.contentType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedBandcamp>, I>>(base?: I): EmbedBandcamp {
    return EmbedBandcamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedBandcamp>, I>>(object: I): EmbedBandcamp {
    const message = createBaseEmbedBandcamp();
    message.contentType = object.contentType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseEmbedAppleMusic(): EmbedAppleMusic {
  return { albumId: "", trackId: "" };
}

export const EmbedAppleMusic: MessageFns<EmbedAppleMusic> = {
  encode(message: EmbedAppleMusic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.albumId !== "") {
      writer.uint32(10).string(message.albumId);
    }
    if (message.trackId !== "") {
      writer.uint32(18).string(message.trackId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedAppleMusic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedAppleMusic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.albumId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedAppleMusic {
    return {
      albumId: isSet(object.albumId) ? globalThis.String(object.albumId) : "",
      trackId: isSet(object.trackId) ? globalThis.String(object.trackId) : "",
    };
  },

  toJSON(message: EmbedAppleMusic): unknown {
    const obj: any = {};
    if (message.albumId !== "") {
      obj.albumId = message.albumId;
    }
    if (message.trackId !== "") {
      obj.trackId = message.trackId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedAppleMusic>, I>>(base?: I): EmbedAppleMusic {
    return EmbedAppleMusic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedAppleMusic>, I>>(object: I): EmbedAppleMusic {
    const message = createBaseEmbedAppleMusic();
    message.albumId = object.albumId ?? "";
    message.trackId = object.trackId ?? "";
    return message;
  },
};

function createBaseEmbedStreamable(): EmbedStreamable {
  return { id: "" };
}

export const EmbedStreamable: MessageFns<EmbedStreamable> = {
  encode(message: EmbedStreamable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedStreamable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedStreamable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedStreamable {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: EmbedStreamable): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedStreamable>, I>>(base?: I): EmbedStreamable {
    return EmbedStreamable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedStreamable>, I>>(object: I): EmbedStreamable {
    const message = createBaseEmbedStreamable();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseEmbedWebsiteMetadata(): EmbedWebsiteMetadata {
  return {
    url: undefined,
    originalUrl: undefined,
    special: undefined,
    title: undefined,
    description: undefined,
    image: undefined,
    video: undefined,
    siteName: undefined,
    iconUrl: undefined,
    colour: undefined,
  };
}

export const EmbedWebsiteMetadata: MessageFns<EmbedWebsiteMetadata> = {
  encode(message: EmbedWebsiteMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== undefined) {
      writer.uint32(10).string(message.url);
    }
    if (message.originalUrl !== undefined) {
      writer.uint32(18).string(message.originalUrl);
    }
    if (message.special !== undefined) {
      EmbedWebsiteMetadataSpecial.encode(message.special, writer.uint32(26).fork()).join();
    }
    if (message.title !== undefined) {
      writer.uint32(34).string(message.title);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.image !== undefined) {
      EmbedImage.encode(message.image, writer.uint32(50).fork()).join();
    }
    if (message.video !== undefined) {
      EmbedVideo.encode(message.video, writer.uint32(58).fork()).join();
    }
    if (message.siteName !== undefined) {
      writer.uint32(66).string(message.siteName);
    }
    if (message.iconUrl !== undefined) {
      writer.uint32(74).string(message.iconUrl);
    }
    if (message.colour !== undefined) {
      writer.uint32(82).string(message.colour);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedWebsiteMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedWebsiteMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originalUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.special = EmbedWebsiteMetadataSpecial.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.image = EmbedImage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.video = EmbedVideo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.siteName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.iconUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.colour = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedWebsiteMetadata {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      originalUrl: isSet(object.originalUrl) ? globalThis.String(object.originalUrl) : undefined,
      special: isSet(object.special) ? EmbedWebsiteMetadataSpecial.fromJSON(object.special) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      image: isSet(object.image) ? EmbedImage.fromJSON(object.image) : undefined,
      video: isSet(object.video) ? EmbedVideo.fromJSON(object.video) : undefined,
      siteName: isSet(object.siteName) ? globalThis.String(object.siteName) : undefined,
      iconUrl: isSet(object.iconUrl) ? globalThis.String(object.iconUrl) : undefined,
      colour: isSet(object.colour) ? globalThis.String(object.colour) : undefined,
    };
  },

  toJSON(message: EmbedWebsiteMetadata): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.originalUrl !== undefined) {
      obj.originalUrl = message.originalUrl;
    }
    if (message.special !== undefined) {
      obj.special = EmbedWebsiteMetadataSpecial.toJSON(message.special);
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.image !== undefined) {
      obj.image = EmbedImage.toJSON(message.image);
    }
    if (message.video !== undefined) {
      obj.video = EmbedVideo.toJSON(message.video);
    }
    if (message.siteName !== undefined) {
      obj.siteName = message.siteName;
    }
    if (message.iconUrl !== undefined) {
      obj.iconUrl = message.iconUrl;
    }
    if (message.colour !== undefined) {
      obj.colour = message.colour;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedWebsiteMetadata>, I>>(base?: I): EmbedWebsiteMetadata {
    return EmbedWebsiteMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedWebsiteMetadata>, I>>(object: I): EmbedWebsiteMetadata {
    const message = createBaseEmbedWebsiteMetadata();
    message.url = object.url ?? undefined;
    message.originalUrl = object.originalUrl ?? undefined;
    message.special = (object.special !== undefined && object.special !== null)
      ? EmbedWebsiteMetadataSpecial.fromPartial(object.special)
      : undefined;
    message.title = object.title ?? undefined;
    message.description = object.description ?? undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? EmbedImage.fromPartial(object.image)
      : undefined;
    message.video = (object.video !== undefined && object.video !== null)
      ? EmbedVideo.fromPartial(object.video)
      : undefined;
    message.siteName = object.siteName ?? undefined;
    message.iconUrl = object.iconUrl ?? undefined;
    message.colour = object.colour ?? undefined;
    return message;
  },
};

function createBaseEmbedText(): EmbedText {
  return {
    iconUrl: undefined,
    url: undefined,
    title: undefined,
    description: undefined,
    media: undefined,
    colour: undefined,
  };
}

export const EmbedText: MessageFns<EmbedText> = {
  encode(message: EmbedText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iconUrl !== undefined) {
      writer.uint32(10).string(message.iconUrl);
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    if (message.title !== undefined) {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.media !== undefined) {
      File.encode(message.media, writer.uint32(42).fork()).join();
    }
    if (message.colour !== undefined) {
      writer.uint32(50).string(message.colour);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbedText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iconUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.media = File.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.colour = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbedText {
    return {
      iconUrl: isSet(object.iconUrl) ? globalThis.String(object.iconUrl) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      media: isSet(object.media) ? File.fromJSON(object.media) : undefined,
      colour: isSet(object.colour) ? globalThis.String(object.colour) : undefined,
    };
  },

  toJSON(message: EmbedText): unknown {
    const obj: any = {};
    if (message.iconUrl !== undefined) {
      obj.iconUrl = message.iconUrl;
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.media !== undefined) {
      obj.media = File.toJSON(message.media);
    }
    if (message.colour !== undefined) {
      obj.colour = message.colour;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbedText>, I>>(base?: I): EmbedText {
    return EmbedText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbedText>, I>>(object: I): EmbedText {
    const message = createBaseEmbedText();
    message.iconUrl = object.iconUrl ?? undefined;
    message.url = object.url ?? undefined;
    message.title = object.title ?? undefined;
    message.description = object.description ?? undefined;
    message.media = (object.media !== undefined && object.media !== null) ? File.fromPartial(object.media) : undefined;
    message.colour = object.colour ?? undefined;
    return message;
  },
};

function createBaseEmbed(): Embed {
  return { website: undefined, image: undefined, video: undefined, text: undefined, none: undefined };
}

export const Embed: MessageFns<Embed> = {
  encode(message: Embed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.website !== undefined) {
      EmbedWebsiteMetadata.encode(message.website, writer.uint32(10).fork()).join();
    }
    if (message.image !== undefined) {
      EmbedImage.encode(message.image, writer.uint32(18).fork()).join();
    }
    if (message.video !== undefined) {
      EmbedVideo.encode(message.video, writer.uint32(26).fork()).join();
    }
    if (message.text !== undefined) {
      EmbedText.encode(message.text, writer.uint32(34).fork()).join();
    }
    if (message.none !== undefined) {
      Empty.encode(message.none, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Embed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.website = EmbedWebsiteMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = EmbedImage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.video = EmbedVideo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = EmbedText.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.none = Empty.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Embed {
    return {
      website: isSet(object.website) ? EmbedWebsiteMetadata.fromJSON(object.website) : undefined,
      image: isSet(object.image) ? EmbedImage.fromJSON(object.image) : undefined,
      video: isSet(object.video) ? EmbedVideo.fromJSON(object.video) : undefined,
      text: isSet(object.text) ? EmbedText.fromJSON(object.text) : undefined,
      none: isSet(object.none) ? Empty.fromJSON(object.none) : undefined,
    };
  },

  toJSON(message: Embed): unknown {
    const obj: any = {};
    if (message.website !== undefined) {
      obj.website = EmbedWebsiteMetadata.toJSON(message.website);
    }
    if (message.image !== undefined) {
      obj.image = EmbedImage.toJSON(message.image);
    }
    if (message.video !== undefined) {
      obj.video = EmbedVideo.toJSON(message.video);
    }
    if (message.text !== undefined) {
      obj.text = EmbedText.toJSON(message.text);
    }
    if (message.none !== undefined) {
      obj.none = Empty.toJSON(message.none);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Embed>, I>>(base?: I): Embed {
    return Embed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Embed>, I>>(object: I): Embed {
    const message = createBaseEmbed();
    message.website = (object.website !== undefined && object.website !== null)
      ? EmbedWebsiteMetadata.fromPartial(object.website)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? EmbedImage.fromPartial(object.image)
      : undefined;
    message.video = (object.video !== undefined && object.video !== null)
      ? EmbedVideo.fromPartial(object.video)
      : undefined;
    message.text = (object.text !== undefined && object.text !== null) ? EmbedText.fromPartial(object.text) : undefined;
    message.none = (object.none !== undefined && object.none !== null) ? Empty.fromPartial(object.none) : undefined;
    return message;
  },
};

function createBaseInteractions(): Interactions {
  return { reactions: [], restrictReactions: false };
}

export const Interactions: MessageFns<Interactions> = {
  encode(message: Interactions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reactions) {
      writer.uint32(10).string(v!);
    }
    if (message.restrictReactions !== false) {
      writer.uint32(16).bool(message.restrictReactions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interactions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInteractions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reactions.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.restrictReactions = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interactions {
    return {
      reactions: globalThis.Array.isArray(object?.reactions)
        ? object.reactions.map((e: any) => globalThis.String(e))
        : [],
      restrictReactions: isSet(object.restrictReactions) ? globalThis.Boolean(object.restrictReactions) : false,
    };
  },

  toJSON(message: Interactions): unknown {
    const obj: any = {};
    if (message.reactions?.length) {
      obj.reactions = message.reactions;
    }
    if (message.restrictReactions !== false) {
      obj.restrictReactions = message.restrictReactions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Interactions>, I>>(base?: I): Interactions {
    return Interactions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Interactions>, I>>(object: I): Interactions {
    const message = createBaseInteractions();
    message.reactions = object.reactions?.map((e) => e) || [];
    message.restrictReactions = object.restrictReactions ?? false;
    return message;
  },
};

function createBaseMasquerade(): Masquerade {
  return { name: undefined, avatar: undefined, colour: undefined };
}

export const Masquerade: MessageFns<Masquerade> = {
  encode(message: Masquerade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.avatar !== undefined) {
      writer.uint32(18).string(message.avatar);
    }
    if (message.colour !== undefined) {
      writer.uint32(26).string(message.colour);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Masquerade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasquerade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.colour = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Masquerade {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : undefined,
      colour: isSet(object.colour) ? globalThis.String(object.colour) : undefined,
    };
  },

  toJSON(message: Masquerade): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.avatar !== undefined) {
      obj.avatar = message.avatar;
    }
    if (message.colour !== undefined) {
      obj.colour = message.colour;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Masquerade>, I>>(base?: I): Masquerade {
    return Masquerade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Masquerade>, I>>(object: I): Masquerade {
    const message = createBaseMasquerade();
    message.name = object.name ?? undefined;
    message.avatar = object.avatar ?? undefined;
    message.colour = object.colour ?? undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    id: "",
    nonce: undefined,
    channelId: "",
    authorId: "",
    webhook: undefined,
    content: undefined,
    system: undefined,
    attachments: [],
    edited: undefined,
    embeds: [],
    mentions: [],
    roleMentions: [],
    replies: [],
    reactions: {},
    interactions: undefined,
    masquerade: undefined,
    pinned: undefined,
    flags: undefined,
  };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nonce !== undefined) {
      writer.uint32(18).string(message.nonce);
    }
    if (message.channelId !== "") {
      writer.uint32(26).string(message.channelId);
    }
    if (message.authorId !== "") {
      writer.uint32(34).string(message.authorId);
    }
    if (message.webhook !== undefined) {
      MessageWebhook.encode(message.webhook, writer.uint32(42).fork()).join();
    }
    if (message.content !== undefined) {
      writer.uint32(50).string(message.content);
    }
    if (message.system !== undefined) {
      MessageSystem.encode(message.system, writer.uint32(58).fork()).join();
    }
    for (const v of message.attachments) {
      File.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.edited !== undefined) {
      writer.uint32(72).int64(message.edited);
    }
    for (const v of message.embeds) {
      Embed.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.mentions) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.roleMentions) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.replies) {
      writer.uint32(106).string(v!);
    }
    Object.entries(message.reactions).forEach(([key, value]) => {
      Message_ReactionsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    if (message.interactions !== undefined) {
      Interactions.encode(message.interactions, writer.uint32(122).fork()).join();
    }
    if (message.masquerade !== undefined) {
      Masquerade.encode(message.masquerade, writer.uint32(130).fork()).join();
    }
    if (message.pinned !== undefined) {
      writer.uint32(136).bool(message.pinned);
    }
    if (message.flags !== undefined) {
      writer.uint32(144).int32(message.flags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authorId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.webhook = MessageWebhook.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.system = MessageSystem.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attachments.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.edited = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.embeds.push(Embed.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.mentions.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.roleMentions.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.replies.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = Message_ReactionsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.reactions[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.interactions = Interactions.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.masquerade = Masquerade.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.pinned = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.flags = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      authorId: isSet(object.authorId) ? globalThis.String(object.authorId) : "",
      webhook: isSet(object.webhook) ? MessageWebhook.fromJSON(object.webhook) : undefined,
      content: isSet(object.content) ? globalThis.String(object.content) : undefined,
      system: isSet(object.system) ? MessageSystem.fromJSON(object.system) : undefined,
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => File.fromJSON(e))
        : [],
      edited: isSet(object.edited) ? globalThis.String(object.edited) : undefined,
      embeds: globalThis.Array.isArray(object?.embeds) ? object.embeds.map((e: any) => Embed.fromJSON(e)) : [],
      mentions: globalThis.Array.isArray(object?.mentions) ? object.mentions.map((e: any) => globalThis.String(e)) : [],
      roleMentions: globalThis.Array.isArray(object?.roleMentions)
        ? object.roleMentions.map((e: any) => globalThis.String(e))
        : [],
      replies: globalThis.Array.isArray(object?.replies) ? object.replies.map((e: any) => globalThis.String(e)) : [],
      reactions: isObject(object.reactions)
        ? Object.entries(object.reactions).reduce<{ [key: string]: StringArray }>((acc, [key, value]) => {
          acc[key] = StringArray.fromJSON(value);
          return acc;
        }, {})
        : {},
      interactions: isSet(object.interactions) ? Interactions.fromJSON(object.interactions) : undefined,
      masquerade: isSet(object.masquerade) ? Masquerade.fromJSON(object.masquerade) : undefined,
      pinned: isSet(object.pinned) ? globalThis.Boolean(object.pinned) : undefined,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.authorId !== "") {
      obj.authorId = message.authorId;
    }
    if (message.webhook !== undefined) {
      obj.webhook = MessageWebhook.toJSON(message.webhook);
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    if (message.system !== undefined) {
      obj.system = MessageSystem.toJSON(message.system);
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => File.toJSON(e));
    }
    if (message.edited !== undefined) {
      obj.edited = message.edited;
    }
    if (message.embeds?.length) {
      obj.embeds = message.embeds.map((e) => Embed.toJSON(e));
    }
    if (message.mentions?.length) {
      obj.mentions = message.mentions;
    }
    if (message.roleMentions?.length) {
      obj.roleMentions = message.roleMentions;
    }
    if (message.replies?.length) {
      obj.replies = message.replies;
    }
    if (message.reactions) {
      const entries = Object.entries(message.reactions);
      if (entries.length > 0) {
        obj.reactions = {};
        entries.forEach(([k, v]) => {
          obj.reactions[k] = StringArray.toJSON(v);
        });
      }
    }
    if (message.interactions !== undefined) {
      obj.interactions = Interactions.toJSON(message.interactions);
    }
    if (message.masquerade !== undefined) {
      obj.masquerade = Masquerade.toJSON(message.masquerade);
    }
    if (message.pinned !== undefined) {
      obj.pinned = message.pinned;
    }
    if (message.flags !== undefined) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.id = object.id ?? "";
    message.nonce = object.nonce ?? undefined;
    message.channelId = object.channelId ?? "";
    message.authorId = object.authorId ?? "";
    message.webhook = (object.webhook !== undefined && object.webhook !== null)
      ? MessageWebhook.fromPartial(object.webhook)
      : undefined;
    message.content = object.content ?? undefined;
    message.system = (object.system !== undefined && object.system !== null)
      ? MessageSystem.fromPartial(object.system)
      : undefined;
    message.attachments = object.attachments?.map((e) => File.fromPartial(e)) || [];
    message.edited = object.edited ?? undefined;
    message.embeds = object.embeds?.map((e) => Embed.fromPartial(e)) || [];
    message.mentions = object.mentions?.map((e) => e) || [];
    message.roleMentions = object.roleMentions?.map((e) => e) || [];
    message.replies = object.replies?.map((e) => e) || [];
    message.reactions = Object.entries(object.reactions ?? {}).reduce<{ [key: string]: StringArray }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = StringArray.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.interactions = (object.interactions !== undefined && object.interactions !== null)
      ? Interactions.fromPartial(object.interactions)
      : undefined;
    message.masquerade = (object.masquerade !== undefined && object.masquerade !== null)
      ? Masquerade.fromPartial(object.masquerade)
      : undefined;
    message.pinned = object.pinned ?? undefined;
    message.flags = object.flags ?? undefined;
    return message;
  },
};

function createBaseMessage_ReactionsEntry(): Message_ReactionsEntry {
  return { key: "", value: undefined };
}

export const Message_ReactionsEntry: MessageFns<Message_ReactionsEntry> = {
  encode(message: Message_ReactionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      StringArray.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message_ReactionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage_ReactionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = StringArray.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message_ReactionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? StringArray.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Message_ReactionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = StringArray.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message_ReactionsEntry>, I>>(base?: I): Message_ReactionsEntry {
    return Message_ReactionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message_ReactionsEntry>, I>>(object: I): Message_ReactionsEntry {
    const message = createBaseMessage_ReactionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? StringArray.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
